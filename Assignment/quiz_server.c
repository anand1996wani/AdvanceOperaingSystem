/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "quiz.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <time.h>

char questions[50][250]; 
char options[50][100];
int correct[10] = {3,4,3,4,3,4,3,4,3,4};
int marks[200];//contains global marks
char password[200][10];
int active[200];//contains marks of active users . others are 0
int numOfClients=0;
int checkRepeat[200][50];
int currentQuestion[200];//contains last question of corresponding client
int flag=0;//if flag becomes 1 , it means it has already stored the questions and answers from file


void initialize()
{
	        
	char temp[20000];
	FILE *fp;
	if((fp=fopen("questions.txt", "r"))==NULL){
            printf("Cannot open file \n");
            exit(0);
        }
        int i=0;char c;
        while (c!= EOF)
            c= temp[i++] = fgetc(fp);
        temp[i]='\0';
        fclose(fp);
        int first = 1;
        int index=0; int k=0; int flagQues=0;
        for(int j=0;j<i;j++){
             if(temp[j]==')' && first){
             	flagQues=1;
             	first = 0;
             	continue;
             }
             if(temp[j]!='\n'){
                if(flagQues)
        	   questions[index][k++]=temp[j];
             }
             else{
             	questions[index][k]='\0';
             	index++;
             	k=0;
             	flagQues=0;
             	first = 1;
             }
        }	


        char tempAns[20000];
	FILE *fp2;
	if((fp2=fopen("answers.txt", "r"))==NULL){
            printf("Cannot open file \n");
            exit(0);
        }
        i=0;char c2;
        while (c2!= EOF)
            c2= tempAns[i++] = fgetc(fp2);
        tempAns[i]='\0';
        fclose(fp2);
        index=0; k=0; int flagAns=0;
        for(int j=0;j<i;j++){
             if(tempAns[j]==')'){
             	flagAns=1;
             	continue;
             }
             if(tempAns[j]!='\n'){
                if(flagAns)
        	   options[index][k++]=tempAns[j];
             }
             else{
             	options[index][k]='\0';
             	index++;
             	k=0;
             	flagAns=0;
             }
        }	
}

assignId *getid_1_svc(credentials *in, struct svc_req *rqstp)
{
	static assignId  out;
	if(in->clientId==-1 ){
		out.clientId = numOfClients++;
		for(int i=0;i<strlen(in->password);i++)
		   password[out.clientId][i]=in->password[i];
	}
	
	if(flag==0){
		 initialize();
		 flag=1;
	}
	return(&out);
}

int compare(char *s1,char *s2)
{
	int i=0;
	if(strlen(s1) != strlen(s2)) return 0;
	for(i=0;i<strlen(s1);i++)
		if(s1[i] != s2[i]) return 0;
	for(i=0;i<strlen(s2);i++)
		if(s1[i]!=s2[i]) return 0;
	if(s2[i]!='\0') return 0;
	return 1;
}

serverEvaluate *login_1_svc(credentials *in, struct svc_req *rqstp)
{
	static serverEvaluate  out;
	/*if(compare(in->password,password[in->clientId]) == 1){
		out.correct=1;
	}*/
	if(strcmp(password[in->clientId],in->password)==0) out.correct=1;
	else out.correct =0;
	return (&out);
}

serverQuiz *getquestion_1_svc(clientSend *in, struct svc_req *rqstp)
{
	static serverQuiz  out;
	int clientId= in->clientId;
	srand(time(0));
	int ran = rand();
	ran=ran%50;
	while(checkRepeat[clientId][ran]==1){
		ran++;
		ran=ran%50;
	}
	checkRepeat[clientId][ran]=1;
	currentQuestion[in->clientId] = ran;
	strcpy(out.question,questions[currentQuestion[in->clientId]]);
	strcpy(out.option,options[currentQuestion[in->clientId]]);
	
	
	return(&out);
}
serverEvaluate *evaluateanswer_1_svc(clientAns *in, struct svc_req *rqstp)
{
	static serverEvaluate out;
	int clientId = in->clientId;
	char ans[100];
	strcpy(ans,in->answer);
	int cor=1;
	for(int i=0;i<strlen(ans) ;i++){
		if(ans[i] != options[currentQuestion[clientId]][i]){
			 cor= 0;
			 break;
		}
	}	
	if(cor == 1){
		out.correct=1;//correct
		marks[clientId]++;
		active[clientId]++;
	}
	else{
		out.correct=0;//incorrect
	}
	//currentQuestion[clientId]++;
	
	return (&out);
	
}

serverEvaluate *getscore_1_svc(clientSend *in, struct svc_req *rqstp)
{
	static serverEvaluate out;
	int clientId = in->clientId;
	out.correct = marks[clientId];
	return (&out);
}
int cmpfunc (const void * a, const void * b) {
   return ( *(int*)b - *(int*)a );
}
rank *getrank_1_svc(clientSend *in, struct svc_req *rqstp)
{
	static rank out;
	int clientId = in->clientId;
	int temp [200];
	for(int i = 0;i < 200;i++){
		temp[i] = marks[i];
	}
	qsort(temp, 200, sizeof(int), cmpfunc);
	int rank=0;int m=marks[clientId];
	for(int i=0;i<200;i++){
		if(temp[i]==m){
			rank=i+1;
			break;
		}
	}
	out.globalRank=rank;
	
	for(int i = 0;i < 200;i++){
		temp[i] = active[i];
	}
	qsort(temp, 200, sizeof(int), cmpfunc);
	rank=0; m=active[clientId];
	for(int i=0;i<200;i++){
		if(temp[i]==m){
			rank=i+1;
			break;
		}
	}
	out.sessionRank=rank;
	return (&out);
}



serverEvaluate *exit_1_svc(clientSend *in, struct svc_req *rqstp)
{
	static serverEvaluate out;
	int clientId = in->clientId;
	active[clientId]=0;
	strcpy(password[clientId],"");
	out.correct=1;
	return (&out);
}





